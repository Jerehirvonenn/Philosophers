Philosophers"I never thought philosophy would be so deadly"This project is a classic computer science problem that explores synchronization, resource management, and concurrency. The goal is to simulate a group of philosophers sitting at a round table who alternate between thinking, eating, and sleeping. The challenge lies in preventing them from starving or deadlocking while competing for a limited number of forks.This implementation is written entirely in C and uses pthreads and mutexesTable of ContentsThe ProblemHow It WorksGetting StartedPrerequisitesInstallation & CompilationUsageRules & ConstraintsMandatory PartBonus PartThe ProblemThe dining philosophers problem is stated as follows:A number of philosophers are sitting at a round table.In the center of the table, there is a large bowl of spaghetti.Between each pair of adjacent philosophers, there is one fork. There are as many forks as there are philosophers.To eat, a philosopher needs to pick up both their left and right forks.A philosopher can only pick up one fork at a time.When a philosopher is done eating, they put both forks down, making them available to others.The simulation must avoid two main issues:Deadlock: A situation where every philosopher has picked up one fork and is waiting for the other, which is held by their neighbor. No one can proceed, and they all starve.Starvation: A philosopher is perpetually denied access to the forks while others get to eat.How It WorksThis project monitors the state of each philosopher and ensures that no one dies of starvation. Each philosopher is a separate threadA monitoring thread constantly checks if any philosopher has exceeded the time_to_die since their last meal.If a philosopher hasn't eaten within this time, the simulation stops, and a "died" message is printed.To prevent deadlocks, the logic ensures that philosophers cannot indefinitely wait for a fork.The simulation ends either when a philosopher dies or when all philosophers have eaten a specified number of times.Getting StartedFollow these instructions to get a copy of the project up and running on your local machine.PrerequisitesYou'll need a C compiler (like gcc or clang) and make installed on your system.Installation & CompilationClone the repository:git clone [https://github.com/Jerehirvonenn/Philosophers.git](https://github.com/Jerehirvonenn/Philosophers.git)
cd Philosophers
Compile the project:The Makefile includes rules for the mandatory and bonus parts.To compile the mandatory part (philo):makeUsageThe program is run from the command line with the following arguments:./philo number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]
Argument Descriptions:number_of_philosophers: The number of philosophers (and forks).time_to_die (ms): If a philosopher doesn't eat within this time, they die.time_to_eat (ms): The time it takes for a philosopher to eat.time_to_sleep (ms): The time a philosopher sleeps after eating.[number_of_times_each_philosopher_must_eat] (optional): The simulation stops after every philosopher has eaten at least this many times.Example:./philo 5 800 200 200 7
This command will simulate 5 philosophers, who will die if they don't eat for 800ms. They take 200ms to eat and 200ms to sleep. The simulation stops when each has eaten 7 times.The output will show the status of each philosopher in real-time:<timestamp_ms> <philosopher_id> has taken a fork
<timestamp_ms> <philosopher_id> is eating
<timestamp_ms> <philosopher_id> is sleeping
<timestamp_ms> <philosopher_id> is thinking
...
<timestamp_ms> <philosopher_id> died
Rules & ConstraintsMandatory PartProgram name: philoConcurrency: Uses pthreads. Each philosopher is a separate thread.Synchronization: Uses pthread_mutex for each fork to prevent data races. A philosopher must lock the mutexes for both their left and right forks before eating.Forbidden: No global variables are used.
